# TOP

*Выйти получилось, понять не получилось.*

## Показатели их значения

Начнем с основных показателей системы. Именно по ним мы можем бегло прикинуть все ли ок и стоит ли идти дальше. Странно, но в этих шести строчках целая прорва информации.

### Основная информация о системе

```bash
top - 23:37:21 up 15 days, 20:52,  1 user,  load average: 0,00, 0,00, 0,00
```

Итак, поехали. Слева на право расположены:

`top - 23:37:21`- время последнего обновления информации. top обновляет показатели каждые три секунда. Изменить период обновления можно с помощью команды `d` которая доступна как ключ при выполнении из консоли и в качестве опции интерактивного режима.

`up 15 days` -  время работы системы с момента запуска.

`20:52` - системное время.

`1 user` - активные сессии пользователей

`load average: 0,00, 0,00, 0,00` - то самое магическое значение.

Все просто и информативно.

### **Tasks**

```bash
Tasks:  81 total,   1 running,  44 sleeping,   0 stopped,   0 zombie
```

- **total** - обычно остаётся достаточно стабильным, но в большое количество процессов может свидетельствовать о проблемах.
- **running** - количество запущенных процессов. Приложения, не поддерживающие многопоточность, например MySQL, могут использовать только один процессор, что часто приводит к ситуациям, когда 1 процесс использует 25% процессора четырехъядерного сервера со средней нагрузкой ~1.
- **sleeping** - показывает какое количество процессов выполняется, но не является активными. Обычно это фоновые задачи, например драйверы принтеров, системное ПО и тд.
- **stopped** - количество остановленных процессов, как правило, должно равняться 0, если вы не остановили процесс самостоятельно.
- **zombie** - зависшие процессы. В нормальной ситуации их число равно 0.

### **CPU**

```bash
%Cpu(s):  0,0 us,  0,2 sy,  0,0 ni, 99,8 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
```

- **%us (user)** - показывает использование отдельного процессора процессами пользователя до максимального значения, составляющего 100%. Если в четырехъядерном процессоре 1 процесс использует 100% CPU, это даст значение %us, равное 25%.
- **%sy (system)** - означает использование CPU системой. Высокие значения могут свидетельствовать о проблеме с конфигурацией ядра, драйверами или целый ряд других вещей.
- **%ni (nice)** - означает процент использования CPU, используемого пользовательскими процессами, на которые повлияло использование команд nice или renice.
- **%id (idle)** - результат, получающийся при вычитании трех предыдущих значений из 100%, и измеряющий простаивающую вычислительную мощность.
- **%wa (iowait)** - процент времени, в течении которого процессор простаивал ожидания завершения операции ввода-вывода. Если значение IO Wait стабильно превышает {100 / (кол-во CPU * кол-во процессов)}%, это означает, что, возможно, имеется проблема хранения, с которой необходимо разобраться.
- **%hi (hardware interruption)** - время, которое тратиться на прерывания на уровне железа. Чрезвычайно высокая пропускная способность сети, использование USB, вычисления на графических процессорах, — все это может привести к росту этого параметра на величину, превышающую несколько процентов.
- **%si (software interrupts)** - прерывания на уровне софта. Если мы применим утилиту tcpdump к гигабитному каналу с высоким трафиком, то значение может измениться примерно на 10%, — по мере заполнения выделенной памяти tcpdump, утилита посылает зарос на прерывание, чтобы переместить данные со стека на диск, экран, или куда угодно еще
- **%st (IO Steal)** - процессорное время, которое гипервизор «крадет» у виртуальной машины. Мера загруженности гипервизора; наличие в каком-либо пуле виртуальных машин, демонстрирующих стабильно высокое значение параметра iosteal% (более 15%) может свидетельствовать о необходимости переноса некоторых из VM в другую часть пула. Если виртуальными процессорами VM используется количество CPU, превышающее количество физических или логических - значение iosteal будет расти.

### Память

```bash
КиБ Mem :  2040744 total,  1581788 free,    61160 used,   397796 buff/cache
КиБ Swap:        0 total,        0 free,        0 used.  1815208 avail Mem
```

В первую очередь стоит помнить что память отображается в KiB (kibibyte), а не килобайтах как мы привыкли. И тут кроется своя история. Дело в том что в далекие годы, когда наша сфера только зарождалась, для определения размерностей использовали систему СИ, она же - метрическая система.

Позже, когда ИТ уже набирала обороты и её влияние стало очевидным, учёные умы сказали что мы неправильно используем систему СИ, поскольку в ней все коэффициенты (мега, кило, гига и тд) являются степенями десятки, в то время как в ИТ используются степени двойки. Это нарушение стандарта, которое порождает путаницу.

Потребовалась новая система, специально для измерений единицы информации. Система в которой все коэффициенты будут представлены степенями двойки. В результате были создана единица измерения информации кибибайт равный 1024 байт, где би - означает двойку.  Полная таблица размерностей:

```bash
KiB = kibibyte = 1024
MiB = mebibyte = 1024 KiB = 1,048,576
GiB = gibibyte = 1024 MiB = 1,073,741,824 bytes
TiB = tebibyte = 1024 GiB = 1,099,511,627,776 bytes
PiB = pebibyte = 1024 TiB = 1,125,899,906,842,624 bytes
EiB = exbibyte = 1024 PiB = 1,152,921,504,606,846,976 bytes
```

Думаю нет смысла описывать каждое значение памяти. Подробнее о них можно прочитать в разделе посвященном памяти в Linux.

### Список процессов

- **%CPU** - процент использования  CPU с момента последнего обновления экрана top.  Поскольку по умолчанию top считает потребление относительно одного ядра процессора, для многоядерных и многопоточных процессоров top может показывать значение более 100 %. Например, если 3 ядра используются на 60%, то в верхней части будет показано использование процессора на 180%.
- **%MEM** - использование памяти в процентах.
- **PR (Priority)** - приоритет планировщика для процесса. Значение `rt` говорит процесс работает в приоритете реального времени.
- **NI (Nice Value)** - значение `nice` для процесса. Чем выше значение, тем больше процесс будет «уступать» другим в использовании процессора. Команда nice запускает программу с изменённым приоритетом для планировщика задач. Слово «nice» в английском языке обозначает, в частности, «вежливый». По этимологии этой команды процесс с большим значением nice — более вежлив к другим процессам, позволяя им использовать больше процессорного времени, поскольку он сам имеет меньший приоритет (и, следовательно, большее «значение вежливости» — niceness value).
*[Оригинал](https://habr.com/ru/post/106381/)*
- **VIRT (Virtual Memory Size)** - количество виртуальной памяти выделенной процессу. В это значение включена память выделенная для хранения кода, информации, разделяемых библиотек и страниц памяти.
- **RES (Resident Memory Size)** - значение физической памяти используемой процессом, без учёта SWAP.
- **SHR** **(Shared Memory Size)** - объем резидентной (RES) памяти памяти который может использоваться другими процессами. Включает в себя общие анонимные страницы и общие страницы, поддерживаемые файлами. Он также включает частные страницы, сопоставленные с файлами, представляющими образы программ и разделяемые библиотеки.
- **S (Process Status)** -  статус процесса. Поговорим о возможных статусах:
  - **D (uninterruptible sleep)** - непрерываемый сон. Тут немного сложно, но если вкратце - процесс не будет реагировать на сигналы kill. Если процесс повиснет в таком состоянии - ты уже не сможешь его убить. Никак. Подробнее можно почитать [тут](https://lwn.net/Articles/288056/) и [тут](https://eklitzke.org/uninterruptible-sleep).
  - **R (running)** - процесс выполняется. Все ок.
  - **S (sleeping)** - процесс находится в состоянии сна. Такое, как правило, происходит с драйверами или системными сервисами когда они не используются или процессами пользователя, с которыми он не взаимодействует.
  - **T (stopped by job control signal)** -  процесс остановлен сигналом управления. В самом простом примере - такой статус получают, например, процессы остановленные с помощью `Ctrl + Z`.
  - **t (stopped by debugger during trace)** - процесс остановлен дебаггером.  Похоже на `T`. Разница лишь в причинах остановки процесса.
  - **Z (zombie)** - зомби процесс. Процесс становиться зомби если он завершился, но информация о нём не была удалена из таблицы процессов. Такое может происходить, например, если дочерний процесс завершился раньше чем ожидал родительский.
- **TIME+ (CPU Time)** - время в течении которого процессор использовал CPU с момента его запуска. Разница между TIME и TIME+ заключается в том что второй показатель отображает сотые доли секунды.
- **TOP** умеет считать время в кумулятивном режиме. Тогда, в значении TIME+ будет отображаться время использования CPU процессом и его дочерними процессами, что дает более и адекватную подробную картину. Для переключения между режимами используй `S`.
- **COMMAND (Command Name or Command Line)** - отображает имя или путь до выполняемой команды. Переключится между режимами можно с помощью `c`.

Но это далеко не все. Нажав `Shift + F` мы увидим огромное количество дополнительных полей, которые выключены по умолчанию. Используй стрелки чтобы перейти к нужному полю, `Space` для выбора и `Esc` для возврата к основному экрану. Описание полей можно найти в `man top`.

## Клавиши

По умолчанию top довольно информативен, но можно сделать его еще круче.

### Отображение

`1` - отображаем значение CPU для каждого ядра.

`B` - выделить показатели системы.

`E` - переключаем размерность строки MEM. Предпочитаю мебибайты.

`e` - переключаем размерность показателей памяти в списке процессов.

`b` - подсвечиваем активные процессы.

`x` - подсвечиваем параметр, по которому производится сортировка.

`c` - отображаем полный путь до исполняемого файла вместо имени в COMMAND.

`V` - древовидная структура.

`i` - показывать только активные процессы.

`d` - задать частоту обновления. По умолчанию top обновляет информацию каждые 3 секунды.

`W` - сохраняем конфигурацию в файл `~/.toprc`

### Фильтрация

`U` - показывать только процессы определенного пользователя. После нажатия потребуется ввести имя. Если перед именем указать `!` будут показаны все процессы, кроме процессов пользователя.

`o` - фильтрация по значению полей. После нажатия нужно указать поле и значение, например:

```bash
COMMAND=getty # показать только процессы getty
!COMMAND=getty # показать все процессы, кроме getty
%CPU>3.0 # показать все процессы с потреблением CPU > 3.0
```

Выполни `top -O` из терминала чтобы увидеть поля доступные для фильтрации.

`=` - сбросить все фильтры.

### Сортировка

`F` - выбрать поле для сортировки. Их много. Подробное описание полей есть в `man top`.

`<` и `>` - переключить поле, по которому осуществляется сортировка.

### Поиск

`L` - позволит найти подстроку в выводе top. Используй `=` для сброса.

### Управление процессами

`k` - позволяет послать сигнал процессу. Нужно указать PID и номер сигнала. Увидеть доступные сигналы и их номера можно выполнив `kill -l` в терминале.

### Опции командной строки

`-b` - вывести результат в консоль.

`-n` - указать количество циклов, которое должен отработать top. Длинная цикла равна `delay`.

`-d` - указать время обновления (delay) в секундах. Можно указывать сотые.

`-i` - показать только активные процессы.

`-o` - указать поле для сортировки.

`-p` - показать данные для указанных процессов.

Это лишь малая часть доступных опций. top умеет очень много. Найти подробное описание команд и опций можно в `man top`.

## Послесловие

top - потрясная утилита. Зашел на сервер, бахнул три буквы, понял общую картину и определил направление для дальнейшего траблшутинга. Круто, удобно, аутентично. Must have любого фиксика.

## Источники

1. man top - самый лучший источник
2. [Практические рекомендации: устраняйте неполадки, используя команду 'Top' в Linux](https://habr.com/ru/company/host-tracker/blog/220413/)
3. [TASK_KILLABLE](https://lwn.net/Articles/288056/)
4. [Uninterruptible Sleep](https://eklitzke.org/uninterruptible-sleep)
5. [Процессы в Linux](http://www.opennet.ru/docs/RUS/lnx_process/)
6. [What is Zombie Process in Linux?](https://www.tutorialspoint.com/what-is-zombie-process-in-linux)
